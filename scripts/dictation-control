#!/bin/bash

STATE_FILE="/tmp/voice-dictation-state"
MEDIA_STATE_FILE="/tmp/voice-dictation-media-state"
ENGINE_BIN="$HOME/.local/bin/dictation-engine"
GUI_BIN="$HOME/.local/bin/dictation-gui"
CONTROL_SOCKET="/tmp/voice-dictation-control.sock"

get_state() {
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo "stopped"
    fi
}

set_state() {
    echo "$1" > "$STATE_FILE"
}

send_confirm() {
    python3 "$(dirname "$0")/send_confirm.py"
}

case "$1" in
    start)
        STATE=$(get_state)
        if [ "$STATE" != "stopped" ]; then
            echo "Voice dictation already running (state: $STATE)"
            exit 0
        fi
        
        # Check if media is playing and save state
        if playerctl status 2>/dev/null | grep -q "Playing"; then
            echo "playing" > "$MEDIA_STATE_FILE"
        else
            echo "stopped" > "$MEDIA_STATE_FILE"
        fi
        
        # Change to repo directory so models can be found
        cd ~/repos/voice-dictation-rust
        RUST_LOG=info $ENGINE_BIN > /tmp/dictation-engine.log 2>&1 &
        sleep 0.3
        $GUI_BIN > /tmp/dictation-gui.log 2>&1 < /dev/null &
        
        playerctl pause 2>/dev/null || true
        
        set_state "recording"
        echo "Voice dictation started - recording"
        ;;
        
    stop)
        STATE=$(get_state)
        if [ "$STATE" = "stopped" ]; then
            echo "Voice dictation not running"
            exit 0
        fi
        
        pkill -TERM -f dictation-engine
        pkill -TERM -f dictation-gui
        
        # Resume media if it was playing before
        if [ -f "$MEDIA_STATE_FILE" ] && grep -q "playing" "$MEDIA_STATE_FILE"; then
            playerctl play 2>/dev/null || true
        fi
        rm -f "$MEDIA_STATE_FILE"
        
        set_state "stopped"
        rm -f "$CONTROL_SOCKET"
        echo "Voice dictation stopped"
        ;;
        
    confirm)
        STATE=$(get_state)
        if [ "$STATE" != "recording" ]; then
            echo "Not in recording state (current: $STATE)"
            exit 1
        fi
        
        echo "Sending confirm command..."
        send_confirm
        
        # Wait for engine to finish (it will exit when done)
        # Check every 0.5s for up to 30 seconds
        for i in {1..60}; do
            if ! pgrep -f dictation-engine > /dev/null; then
                break
            fi
            sleep 0.5
        done
        
        # Now kill GUI
        pkill -TERM -f dictation-gui 2>/dev/null
        
        # Resume media if it was playing before
        if [ -f "$MEDIA_STATE_FILE" ] && grep -q "playing" "$MEDIA_STATE_FILE"; then
            playerctl play 2>/dev/null || true
        fi
        rm -f "$MEDIA_STATE_FILE"
        
        set_state "stopped"
        rm -f "$CONTROL_SOCKET"
        echo "Transcription confirmed - typed successfully"
        ;;
        
    toggle)
        STATE=$(get_state)
        
        if [ "$STATE" = "stopped" ]; then
            $0 start
        elif [ "$STATE" = "recording" ]; then
            $0 confirm
        else
            echo "Unknown state: $STATE"
            exit 1
        fi
        ;;
        
    status)
        STATE=$(get_state)
        echo "State: $STATE"
        
        if [ "$STATE" != "stopped" ]; then
            pgrep -f dictation-engine > /dev/null && echo "  Engine: running" || echo "  Engine: NOT running"
            pgrep -f dictation-gui > /dev/null && echo "  GUI: running" || echo "  GUI: NOT running"
        fi
        ;;
        
    *)
        echo "Usage: $0 {start|stop|confirm|toggle|status}"
        exit 1
        ;;
esac
